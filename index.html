<!DOCTYPE html>
<html lang="zh-Hans">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
	<meta name="theme-color" content="#ffffff" />
	<link rel="manifest" href="manifest.json">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black">
	<meta name="apple-mobile-web-app-title" content="壽注籤">

	<title>Sacred Choice Ritual</title>
	<style>
		:root {
			--bg: #fff;
			--fg: #111;
			--muted: #777;
			--line: #e9e9e9;
			--shadow: 0 10px 30px rgba(0, 0, 0, 0.06);
			--radius: 18px;
			--pad: 18px;
			--mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
				"Liberation Mono", "Courier New", monospace;
			--jp: "Hiragino Sans", "Hiragino Kaku Gothic ProN",
				"Hiragino Kaku Gothic Pro", -apple-system,
				BlinkMacSystemFont, "SF Pro Text", "SF Pro Display",
				"Noto Sans JP", "Yu Gothic", "Meiryo", system-ui, sans-serif;
		}

		* {
			box-sizing: border-box;
		}

		html,
		body {
			height: 100%;
		}

		body {
			margin: 0;
			background: var(--bg);
			color: var(--fg);
			font-family: var(--jp);
			letter-spacing: 0.2px;
			-webkit-font-smoothing: antialiased;
			-moz-osx-font-smoothing: grayscale;
		}

		.wrap {
			min-height: 100%;
			display: flex;
			align-items: center;
			justify-content: center;
			padding: calc(env(safe-area-inset-top) + 16px) calc(env(safe-area-inset-right) + 16px) calc(env(safe-area-inset-bottom) + 16px) calc(env(safe-area-inset-left) + 16px);
		}

		.card {
			width: min(720px, 100%);
			border: 1px solid var(--line);
			border-radius: var(--radius);
			box-shadow: var(--shadow);
			overflow: hidden;
			background: #fff;
		}

		header {
			display: flex;
			align-items: flex-end;
			justify-content: space-between;
			gap: 12px;
			padding: 22px var(--pad) 14px;
			border-bottom: 1px solid var(--line);
		}

		.title {
			display: flex;
			flex-direction: column;
			gap: 6px;
		}

		h1 {
			font-size: 15px;
			font-weight: 600;
			margin: 0;
		}

		.sub {
			font-size: 12px;
			color: var(--muted);
			margin: 0;
		}

		.actions {
			display: flex;
			gap: 8px;
			align-items: center;
		}

		button {
			font-family: var(--jp);
			border: 1px solid var(--line);
			background: #fff;
			color: var(--fg);
			padding: 9px 12px;
			border-radius: 999px;
			font-size: 12px;
			cursor: pointer;
			transition: transform 0.04s ease, background 0.2s ease;
			user-select: none;
			-webkit-tap-highlight-color: transparent;
		}

		button:active {
			transform: translateY(1px);
		}

		button:hover {
			background: #fafafa;
		}

		main {
			padding: var(--pad);
		}

		textarea {
			width: 100%;
			border: 1px solid var(--line);
			border-radius: 14px;
			padding: 14px;
			font-family: var(--jp);
			font-size: 16px;
			line-height: 1.5;
			resize: vertical;
			min-height: 160px;
			outline: none;
			background: #fff;
		}

		textarea:focus {
			border-color: #d6d6d6;
		}

		.row {
			display: flex;
			gap: 10px;
			align-items: center;
			justify-content: space-between;
			margin-top: 12px;
		}

		.hint {
			font-size: 12px;
			color: var(--muted);
		}

		.muted {
			color: var(--muted);
		}

		.field-grid {
			margin-top: 12px;
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
			gap: 10px;
		}

		.field-grid label {
			font-size: 11px;
			color: var(--muted);
			display: flex;
			flex-direction: column;
			gap: 6px;
		}

		.field-grid input {
			border: 1px solid var(--line);
			border-radius: 12px;
			padding: 10px;
			font-family: var(--jp);
			font-size: 16px;
			background: #fff;
			min-height: 40px;
			outline: none;
		}

		.field-grid input:focus,
		.negation-field input:focus {
			border-color: #cacaca;
		}

		.binary-control {
			margin-top: 10px;
			display: flex;
			flex-wrap: wrap;
			align-items: flex-end;
			gap: 10px;
		}

		.bool-toggle {
			border-radius: 12px;
			padding: 0 16px;
			border: 1px solid var(--line);
			background: #fff;
			font-size: 12px;
			cursor: pointer;
			transition: background 0.2s ease, border-color 0.2s ease,
				color 0.2s ease;
			min-height: 44px;
			display: inline-flex;
			align-items: center;
			justify-content: center;
		}

		.bool-toggle.is-active {
			background: #111;
			color: #fff;
			border-color: #111;
		}

		.negation-field {
			display: flex;
			flex-direction: column;
			gap: 6px;
			font-size: 11px;
			color: var(--muted);
		}

		.negation-field input {
			border: 1px solid var(--line);
			border-radius: 12px;
			padding: 10px;
			font-family: var(--jp);
			font-size: 16px;
			background: #fff;
			min-height: 44px;
			outline: none;
			min-width: 100px;
		}

		.negation-field[hidden] {
			display: none;
		}

		.result {
			margin-top: 14px;
			border-top: 1px solid var(--line);
			padding-top: 14px;
		}

		.table-wrapper {
			overflow: hidden;
			border-radius: 14px;
			border: 1px solid var(--line);
			background: #fcfcfc;
		}

		table {
			width: 100%;
			border-collapse: collapse;
		}

		th,
		td {
			text-align: left;
			padding: 10px 12px;
			font-size: 13px;
		}

		thead th {
			font-size: 11px;
			text-transform: uppercase;
			letter-spacing: 0.08em;
			color: var(--muted);
			border-bottom: 1px solid var(--line);
		}

		td.score {
			text-align: left;
			font-variant-numeric: tabular-nums;
		}

		tbody tr+tr td {
			border-top: 1px solid var(--line);
		}

		.tiny {
			margin-top: 10px;
			display: flex;
			gap: 10px;
			align-items: center;
			justify-content: space-between;
			color: var(--muted);
			font-size: 11px;
		}

		.dot {
			width: 6px;
			height: 6px;
			border-radius: 50%;
			background: #111;
			display: inline-block;
			margin-right: 6px;
			opacity: 0.55;
		}

		.kbd {
			font-family: var(--mono);
			font-size: 11px;
			border: 1px solid var(--line);
			background: #fff;
			padding: 2px 6px;
			border-radius: 8px;
			color: #555;
		}

		footer {
			padding: 12px var(--pad) 18px;
			border-top: 1px solid var(--line);
			display: flex;
			justify-content: space-between;
			gap: 10px;
			color: var(--muted);
			font-size: 11px;
		}

		a {
			color: inherit;
			text-decoration: none;
			border-bottom: 1px solid transparent;
		}

		a:hover {
			border-bottom-color: var(--line);
		}

		@media (prefers-reduced-motion: reduce) {
			* {
				transition: none !important;
			}
		}
	</style>
</head>

<body>
	<div class="wrap">
		<div class="card" role="application" aria-label="Sacred Choice Ritual">
			<header>
				<div class="title">
					<h1>壽注籤</h1>
					<p class="sub">Soizoktantas 作製</p>
				</div>
				<div class="actions">
					<button id="btnRun" type="button" title="Run (⌘/Ctrl + Enter)">
						実行
					</button>
					<button id="btnCopy" type="button" title="Copy">
						コピー
					</button>
				</div>
			</header>

			<main>
				<textarea id="input" spellcheck="false" autocapitalize="none" autocomplete="off"
					autocorrect="off"></textarea>
				<div class="field-grid">
					<label>
						前綴
						<input id="prefixInput" type="text" placeholder="" />
					</label>
					<label>
						後綴
						<input id="suffixInput" type="text" placeholder="" />
					</label>
				</div>
				<div class="binary-control">
					<button id="binaryToggle" type="button" class="bool-toggle" aria-pressed="false">
						二選：關
					</button>
					<label id="negationContainer" class="negation-field" hidden>
						否定詞
						<input id="negationInput" type="text" value="不" placeholder="不" />
					</label>
				</div>
				<div class="row">
					<div class="hint">
						<span class="dot"></span><span id="status">待機</span>
					</div>
				</div>

				<div class="result" aria-live="polite">
					<div class="table-wrapper">
						<table>
							<thead>
								<tr>
									<th>選項</th>
									<th>命中</th>
								</tr>
							</thead>
							<tbody id="resultBody">
								<tr>
									<td colspan="2" class="muted">
										等待選項
									</td>
								</tr>
							</tbody>
						</table>
					</div>
					<div id="resultNotes" class="hint"></div>
					<div class="tiny">
						<div id="meta">—</div>
					</div>
				</div>
			</main>
		</div>
	</div>

	<script>
		// ========================
		// Sacred Choice Ritual ─ 單選也能用極簡版
		// ========================

		// OPTIONS_TEXT 來源：輸入框（不依賴外部環境）
		const HASH_LEN = 8;
		const HUANGDI_OFFSET = 2698;
		const TARGET_TZ_OFFSET = 8;

		// SHA256 純 JS 實現（無外部依賴）
		var sha256 = (function () {
			var hexcase = 0;
			var b64pad = "";

			function hex_sha256(s) {
				return rstr2hex(rstr_sha256(str2rstr_utf8(s)));
			}
			function b64_sha256(s) {
				return rstr2b64(rstr_sha256(str2rstr_utf8(s)));
			}
			function any_sha256(s, e) {
				return rstr2any(rstr_sha256(str2rstr_utf8(s)), e);
			}
			function hex_hmac_sha256(k, d) {
				return rstr2hex(
					rstr_hmac_sha256(str2rstr_utf8(k), str2rstr_utf8(d))
				);
			}
			function b64_hmac_sha256(k, d) {
				return rstr2b64(
					rstr_hmac_sha256(str2rstr_utf8(k), str2rstr_utf8(d))
				);
			}
			function any_hmac_sha256(k, d, e) {
				return rstr2any(
					rstr_hmac_sha256(str2rstr_utf8(k), str2rstr_utf8(d)),
					e
				);
			}

			function rstr_sha256(s) {
				return binb2rstr(binb_sha256(rstr2binb(s), s.length * 8));
			}

			function rstr_hmac_sha256(key, data) {
				var bkey = rstr2binb(key);
				if (bkey.length > 16)
					bkey = binb_sha256(bkey, key.length * 8);
				var ipad = Array(16),
					opad = Array(16);
				for (var i = 0; i < 16; i++) {
					ipad[i] = bkey[i] ^ 0x36363636;
					opad[i] = bkey[i] ^ 0x5c5c5c5c;
				}
				var hash = binb_sha256(
					ipad.concat(rstr2binb(data)),
					512 + data.length * 8
				);
				return binb2rstr(binb_sha256(opad.concat(hash), 512 + 256));
			}

			function rstr2hex(input) {
				var hex_tab = hexcase
					? "0123456789ABCDEF"
					: "0123456789abcdef";
				var output = "";
				var x;
				for (var i = 0; i < input.length; i++) {
					x = input.charCodeAt(i);
					output +=
						hex_tab.charAt((x >>> 4) & 0x0f) +
						hex_tab.charAt(x & 0x0f);
				}
				return output;
			}

			function rstr2b64(input) {
				var tab =
					"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
				var output = "";
				var len = input.length;
				for (var i = 0; i < len; i += 3) {
					var triplet =
						(input.charCodeAt(i) << 16) |
						(i + 1 < len ? input.charCodeAt(i + 1) << 8 : 0) |
						(i + 2 < len ? input.charCodeAt(i + 2) : 0);
					for (var j = 0; j < 4; j++) {
						if (i * 8 + j * 6 > input.length * 8)
							output += b64pad;
						else
							output += tab.charAt(
								(triplet >>> (6 * (3 - j))) & 0x3f
							);
					}
				}
				return output;
			}

			function rstr2any(input, encoding) {
				var divisor = encoding.length;
				var remainders = Array();
				var i, q, x, quotient;
				var dividend = Array(Math.ceil(input.length / 2));
				for (i = 0; i < dividend.length; i++) {
					dividend[i] =
						(input.charCodeAt(i * 2) << 8) |
						input.charCodeAt(i * 2 + 1);
				}
				while (dividend.length > 0) {
					quotient = Array();
					x = 0;
					for (i = 0; i < dividend.length; i++) {
						x = (x << 16) + dividend[i];
						q = Math.floor(x / divisor);
						x -= q * divisor;
						if (quotient.length > 0 || q > 0)
							quotient[quotient.length] = q;
					}
					remainders[remainders.length] = x;
					dividend = quotient;
				}
				var output = "";
				for (i = remainders.length - 1; i >= 0; i--)
					output += encoding.charAt(remainders[i]);
				var full_length = Math.ceil(
					(input.length * 8) /
					(Math.log(encoding.length) / Math.log(2))
				);
				for (i = output.length; i < full_length; i++)
					output = encoding[0] + output;
				return output;
			}

			function str2rstr_utf8(input) {
				var output = "";
				var i = -1;
				var x, y;
				while (++i < input.length) {
					x = input.charCodeAt(i);
					y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
					if (
						0xd800 <= x &&
						x <= 0xdbff &&
						0xdc00 <= y &&
						y <= 0xdfff
					) {
						x = 0x10000 + ((x & 0x03ff) << 10) + (y & 0x03ff);
						i++;
					}
					if (x <= 0x7f) output += String.fromCharCode(x);
					else if (x <= 0x7ff)
						output += String.fromCharCode(
							0xc0 | ((x >>> 6) & 0x1f),
							0x80 | (x & 0x3f)
						);
					else if (x <= 0xffff)
						output += String.fromCharCode(
							0xe0 | ((x >>> 12) & 0x0f),
							0x80 | ((x >>> 6) & 0x3f),
							0x80 | (x & 0x3f)
						);
					else if (x <= 0x1fffff)
						output += String.fromCharCode(
							0xf0 | ((x >>> 18) & 0x07),
							0x80 | ((x >>> 12) & 0x3f),
							0x80 | ((x >>> 6) & 0x3f),
							0x80 | (x & 0x3f)
						);
				}
				return output;
			}

			function rstr2binb(input) {
				var output = Array(input.length >> 2);
				for (var i = 0; i < output.length; i++) output[i] = 0;
				for (var i = 0; i < input.length * 8; i += 8)
					output[i >> 5] |=
						(input.charCodeAt(i / 8) & 0xff) << (24 - (i % 32));
				return output;
			}

			function binb2rstr(input) {
				var output = "";
				for (var i = 0; i < input.length * 32; i += 8)
					output += String.fromCharCode(
						(input[i >> 5] >>> (24 - (i % 32))) & 0xff
					);
				return output;
			}

			function safe_add(x, y) {
				var lsw = (x & 0xffff) + (y & 0xffff);
				var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
				return (msw << 16) | (lsw & 0xffff);
			}

			function sha256_S(X, n) {
				return (X >>> n) | (X << (32 - n));
			}
			function sha256_R(X, n) {
				return X >>> n;
			}
			function sha256_Ch(x, y, z) {
				return (x & y) ^ (~x & z);
			}
			function sha256_Maj(x, y, z) {
				return (x & y) ^ (x & z) ^ (y & z);
			}
			function sha256_Sigma0256(x) {
				return sha256_S(x, 2) ^ sha256_S(x, 13) ^ sha256_S(x, 22);
			}
			function sha256_Sigma1256(x) {
				return sha256_S(x, 6) ^ sha256_S(x, 11) ^ sha256_S(x, 25);
			}
			function sha256_Gamma0256(x) {
				return sha256_S(x, 7) ^ sha256_S(x, 18) ^ sha256_R(x, 3);
			}
			function sha256_Gamma1256(x) {
				return sha256_S(x, 17) ^ sha256_S(x, 19) ^ sha256_R(x, 10);
			}

			var sha256_K = [
				1116352408, 1899447441, -1245643825, -373957723, 961987163,
				1508970993, -1841331548, -1424204075, -670586216, 310598401,
				607225278, 1426881987, 1925078388, -2132889090, -1680079193,
				-1046744716, -459576895, -272742522, 264347078, 604807628,
				770255983, 1249150122, 1555081692, 1996064986, -1740746414,
				-1473132947, -1341970488, -1084653625, -958395405,
				-710438585, 113926993, 338241895, 666307205, 773529912,
				1294757372, 1396182291, 1695183700, 1986661051, -2117940946,
				-1838011259, -1564481375, -1474664885, -1035236496,
				-949202525, -778901479, -694614492, -200395387, 275423344,
				430227734, 506948616, 659060556, 883997877, 958139571,
				1322822218, 1537002063, 1747873779, 1955562222, 2024104815,
				-2067236844, -1933114872, -1866530822, -1538233109,
				-1090935817, -965641998,
			];

			function binb_sha256(m, l) {
				var HASH = [
					1779033703, -1150833019, 1013904242, -1521486534,
					1359893119, -1694144372, 528734635, 1541459225,
				];
				var W = new Array(64);
				var a, b, c, d, e, f, g, h;
				var i, j, T1, T2;
				m[l >> 5] |= 0x80 << (24 - (l % 32));
				m[(((l + 64) >> 9) << 4) + 15] = l;
				for (i = 0; i < m.length; i += 16) {
					a = HASH[0];
					b = HASH[1];
					c = HASH[2];
					d = HASH[3];
					e = HASH[4];
					f = HASH[5];
					g = HASH[6];
					h = HASH[7];
					for (j = 0; j < 64; j++) {
						if (j < 16) W[j] = m[j + i];
						else
							W[j] = safe_add(
								safe_add(
									safe_add(
										sha256_Gamma1256(W[j - 2]),
										W[j - 7]
									),
									sha256_Gamma0256(W[j - 15])
								),
								W[j - 16]
							);
						T1 = safe_add(
							safe_add(
								safe_add(
									safe_add(h, sha256_Sigma1256(e)),
									sha256_Ch(e, f, g)
								),
								sha256_K[j]
							),
							W[j]
						);
						T2 = safe_add(
							sha256_Sigma0256(a),
							sha256_Maj(a, b, c)
						);
						h = g;
						g = f;
						f = e;
						e = safe_add(d, T1);
						d = c;
						c = b;
						b = a;
						a = safe_add(T1, T2);
					}
					HASH[0] = safe_add(a, HASH[0]);
					HASH[1] = safe_add(b, HASH[1]);
					HASH[2] = safe_add(c, HASH[2]);
					HASH[3] = safe_add(d, HASH[3]);
					HASH[4] = safe_add(e, HASH[4]);
					HASH[5] = safe_add(f, HASH[5]);
					HASH[6] = safe_add(g, HASH[6]);
					HASH[7] = safe_add(h, HASH[7]);
				}
				return HASH;
			}

			return {
				hex: hex_sha256,
				b64: b64_sha256,
				any: any_sha256,
				hex_hmac: hex_hmac_sha256,
				b64_hmac: b64_hmac_sha256,
				any_hmac: any_hmac_sha256,
			};
		})();

		// 簡單字元寬度計算（近似）
		function str_width(s) {
			return [...s].reduce(
				(sum, c) => sum + (c.charCodeAt(0) > 127 ? 2 : 1),
				0
			);
		}

		function ljust_disp(s, width) {
			return s + " ".repeat(Math.max(0, width - str_width(s)));
		}

		function shichen_from_hour(h) {
			return "子丑寅卯辰巳午未申酉戌亥".charAt(
				(((h + 1) % 24) / 2) | 0
			);
		}

		function compute_match_index(h_int, t_seed) {
			const xor = (h_int ^ t_seed) >>> 0;
			const mod = xor % 101;
			const score = 100 - mod;
			return Math.max(0, Math.min(100, score));
		}

		const BASE_LUNAR_YEAR = 1900;
		const LUNAR_INFO = [
			0x04bd8, 0x04ae0, 0x0a570, 0x054d5, 0x0d260, 0x0d950, 0x16554,
			0x056a0, 0x09ad0, 0x055d2, 0x04ae0, 0x0a5b6, 0x0a4d0, 0x0d250,
			0x1d255, 0x0b540, 0x0d6a0, 0x0ada2, 0x095b0, 0x14977, 0x04970,
			0x0a4b0, 0x0b4b5, 0x06a50, 0x06d40, 0x1ab54, 0x02b60, 0x09570,
			0x052f2, 0x04970, 0x06566, 0x0d4a0, 0x0ea50, 0x06e95, 0x05ad0,
			0x02b60, 0x186e3, 0x092e0, 0x1c8d7, 0x0c950, 0x0d4a0, 0x1d8a6,
			0x0b550, 0x056a0, 0x1a5b4, 0x025d0, 0x092d0, 0x0d2b2, 0x0a950,
			0x0b557, 0x06ca0, 0x0b550, 0x15355, 0x04da0, 0x0a5d0, 0x14573,
			0x052d0, 0x0a9a8, 0x0e950, 0x06aa0, 0x0aea6, 0x0ab50, 0x04b60,
			0x0aae4, 0x0a570, 0x05260, 0x0f263, 0x0d950, 0x05b57, 0x056a0,
			0x096d0, 0x04dd5, 0x04ad0, 0x0a4d0, 0x0d4d4, 0x0d250, 0x0d558,
			0x0b540, 0x0b5a0, 0x195a6, 0x095b0, 0x049b0, 0x0a974, 0x0a4b0,
			0x0b27a, 0x06a50, 0x06d40, 0x0af46, 0x0ab60, 0x09570, 0x04af5,
			0x04970, 0x064b0, 0x074a3, 0x0ea50, 0x06b58, 0x05ac0, 0x0ab60,
			0x096d5, 0x092e0, 0x0c960, 0x0d954, 0x0d4a0, 0x0da50, 0x07552,
			0x056a0, 0x0abb7, 0x025d0, 0x092d0, 0x0cab5, 0x0a950, 0x0b4a0,
			0x0baa4, 0x0ad50, 0x055d9, 0x04ba0, 0x0a5b0, 0x15176, 0x052b0,
			0x0a930, 0x07954, 0x06aa0, 0x0ad50, 0x05b52, 0x04b60, 0x0a6e6,
			0x0a4e0, 0x0d260, 0x0ea65, 0x0d530, 0x05aa0, 0x076a3, 0x096d0,
			0x04bd7, 0x04ad0, 0x0a4d0, 0x1d0b6, 0x0d250, 0x0d520, 0x0dd45,
			0x0b5a0, 0x056d0, 0x055b2, 0x049b0, 0x0a577, 0x0a4b0, 0x0aa50,
			0x1b255, 0x06d20, 0x0ada0, 0x14b63, 0x09370, 0x049f8, 0x04970,
			0x064b0, 0x168a6, 0x0ea50, 0x06aa0, 0x1a6c4, 0x0aae0, 0x0a2e0,
			0x0d2e3, 0x0c960, 0x0d557, 0x0d4a0, 0x0da50, 0x05d55, 0x056a0,
			0x0a6d0, 0x055d4, 0x052d0, 0x0a9b8, 0x0a950, 0x0b4a0, 0x0b6a6,
			0x0ad50, 0x055a0, 0x0aba4, 0x0a5b0, 0x052b0, 0x0b273, 0x06930,
			0x07337, 0x06aa0, 0x0ad50, 0x14b55, 0x04b60, 0x0a570, 0x054e4,
			0x0d160, 0x0e968, 0x0d520, 0x0daa0, 0x16aa6, 0x056d0, 0x04ae0,
			0x0a9d4, 0x0a2d0, 0x0d150, 0x0f252, 0x0d520, 0x0dd45, 0x0b5a0,
			0x056d0, 0x055b3, 0x049b0, 0x0a577, 0x0a4b0, 0x0aa50, 0x1b255,
			0x06d20, 0x0ada0, 0x14b63,
		];

		const BASE_SOLAR_DATE_UTC = Date.UTC(BASE_LUNAR_YEAR, 0, 31);
		const MAX_LUNAR_YEAR = BASE_LUNAR_YEAR + LUNAR_INFO.length - 1;

		function leapMonth(year) {
			if (year < BASE_LUNAR_YEAR || year > MAX_LUNAR_YEAR) return 0;
			return LUNAR_INFO[year - BASE_LUNAR_YEAR] & 0xf;
		}

		function leapMonthDays(year) {
			const leap = leapMonth(year);
			if (!leap) return 0;
			const info = LUNAR_INFO[year - BASE_LUNAR_YEAR];
			return info & 0x10000 ? 30 : 29;
		}

		function monthDays(year, month) {
			if (month < 1 || month > 12) return 0;
			if (year < BASE_LUNAR_YEAR || year > MAX_LUNAR_YEAR) return 0;
			const info = LUNAR_INFO[year - BASE_LUNAR_YEAR];
			return info & (0x10000 >> month) ? 30 : 29;
		}

		function lunarYearDays(year) {
			if (year < BASE_LUNAR_YEAR || year > MAX_LUNAR_YEAR) return 0;
			const info = LUNAR_INFO[year - BASE_LUNAR_YEAR];
			let sum = 348;
			for (let mask = 0x8000; mask > 0x8; mask >>= 1) {
				sum += info & mask ? 1 : 0;
			}
			return sum + leapMonthDays(year);
		}

		function solarToLunar(year, month, day) {
			if (year < BASE_LUNAR_YEAR || year > MAX_LUNAR_YEAR)
				return null;
			const targetUTC = Date.UTC(year, month - 1, day);
			let offset = Math.floor(
				(targetUTC - BASE_SOLAR_DATE_UTC) / 86400000
			);
			if (offset < 0) return null;

			let lunarYear = BASE_LUNAR_YEAR;
			let daysInYear = lunarYearDays(lunarYear);
			while (offset >= daysInYear && lunarYear < MAX_LUNAR_YEAR) {
				offset -= daysInYear;
				lunarYear += 1;
				daysInYear = lunarYearDays(lunarYear);
			}

			const leap = leapMonth(lunarYear);
			let isLeap = false;
			let lunarMonth = 1;

			while (lunarMonth <= 12) {
				const daysInMonth =
					isLeap && leap === lunarMonth
						? leapMonthDays(lunarYear)
						: monthDays(lunarYear, lunarMonth);

				if (offset < daysInMonth) break;
				offset -= daysInMonth;

				if (leap === lunarMonth && !isLeap && leap !== 0) {
					isLeap = true;
				} else {
					if (isLeap && leap === lunarMonth) {
						isLeap = false;
						lunarMonth += 1;
					} else {
						lunarMonth += 1;
					}
				}
			}

			return {
				lunarYear,
				lunarMonth,
				lunarDay: offset + 1,
				isLeap,
			};
		}

		function getNowInTimezone(offsetHours) {
			const tzDate = new Date(Date.now() + offsetHours * 3600 * 1000);
			return {
				year: tzDate.getUTCFullYear(),
				month: tzDate.getUTCMonth() + 1,
				day: tzDate.getUTCDate(),
				hour: tzDate.getUTCHours(),
				minute: tzDate.getUTCMinutes(),
				second: tzDate.getUTCSeconds(),
			};
		}

		async function ritual(
			OPTIONS_TEXT,
			prefix = "",
			suffix = "",
			customDisplays = null
		) {
			try {
				let raw_lines = OPTIONS_TEXT.length
					? OPTIONS_TEXT.split(/\r?\n/)
					: [];
				const raw_opts = [];
				const seen = new Set();
				for (const line of raw_lines) {
					if (seen.has(line)) continue;
					seen.add(line);
					raw_opts.push(line);
				}

				const option_info = [];
				if (Array.isArray(customDisplays)) {
					const customSeen = new Set();
					for (const display of customDisplays) {
						if (!display) continue;
						if (customSeen.has(display)) continue;
						customSeen.add(display);
						const h = sha256.hex(display);
						option_info.push([display, h]);
					}
				} else {
					const prefixValue = prefix || "";
					const suffixValue = suffix || "";
					for (const opt of raw_opts) {
						const display = `${prefixValue}${opt}${suffixValue}`;
						const h = sha256.hex(display);
						option_info.push([display, h]);
					}
				}

				const notes = [];
				const nowParts = getNowInTimezone(TARGET_TZ_OFFSET);
				const hdyr = nowParts.year + HUANGDI_OFFSET;

				let lunar = solarToLunar(
					nowParts.year,
					nowParts.month,
					nowParts.day
				);
				if (!lunar) {
					notes.push(
						"農曆資料超出内建範圍，使用 fallback 陰曆 8 月 15 日"
					);
					lunar = { lunarMonth: 8, lunarDay: 15 };
				}

				const zhi = shichen_from_hour(nowParts.hour);
				const seconds_today =
					nowParts.hour * 3600 +
					nowParts.minute * 60 +
					nowParts.second;
				let ke =
					Math.floor((seconds_today * 100) / (24 * 3600)) + 1;
				ke = Math.min(ke, 100);
				const branch_idx = Math.max(
					0,
					"子丑寅卯辰巳午未申酉戌亥".indexOf(zhi)
				);
				const t_seed =
					(((hdyr << 8) >>> 0) ^
						((lunar.lunarMonth << 4) >>> 0) ^
						(lunar.lunarDay >>> 0) ^
						(branch_idx >>> 0) ^
						(ke >>> 0)) >>>
					0;

				const entries = [];
				for (const [display, h] of option_info) {
					const h_int =
						parseInt(h.substring(0, HASH_LEN), 16) >>> 0;
					const score = compute_match_index(h_int, t_seed);
					entries.push({ display, score });
				}

				entries.sort((a, b) => b.score - a.score);

				return {
					entries,
					notes,
					nowParts,
					lunar,
					zhi,
					ke,
				};
			} catch (error) {
				return {
					entries: [],
					notes: ["error: " + error],
					nowParts: null,
					lunar: null,
					zhi: null,
					ke: null,
				};
			}
		}

		// ========================
		// UI glue
		// ========================
		const $ = (sel) => document.querySelector(sel);
		const input = $("#input");
		const status = $("#status");
		const meta = $("#meta");
		const btnRun = $("#btnRun");
		const btnCopy = $("#btnCopy");
		const resultBody = $("#resultBody");
		const resultNotes = $("#resultNotes");
		const prefixInput = $("#prefixInput");
		const suffixInput = $("#suffixInput");
		const binaryToggle = $("#binaryToggle");
		const negationInput = $("#negationInput");
		const negationContainer = $("#negationContainer");
		let currentResults = [];
		let binaryMode = false;

		function setStatus(t) {
			status.textContent = t;
		}

		function renderResults(entries = []) {
			currentResults = [];
			resultBody.innerHTML = "";
			if (!entries.length) {
				const row = document.createElement("tr");
				const cell = document.createElement("td");
				cell.setAttribute("colspan", "2");
				cell.className = "muted";
				cell.textContent = "輸入選項即可看結果";
				row.appendChild(cell);
				resultBody.appendChild(row);
				return;
			}

			for (const { display, score } of entries) {
				const row = document.createElement("tr");
				const tdLabel = document.createElement("td");
				tdLabel.textContent = display;
				const tdScore = document.createElement("td");
				tdScore.textContent = `${score}%`;
				tdScore.className = "score";
				row.appendChild(tdLabel);
				row.appendChild(tdScore);
				resultBody.appendChild(row);
				currentResults.push({ display, score });
			}
		}

		async function run() {
			setStatus("計算中");
			const prefixValue = prefixInput.value || "";
			const suffixValue = suffixInput.value || "";
			const inputText = input.value || "";
			let ritualInput = inputText;
			let customDisplays = null;
			if (binaryMode) {
				const firstLine = inputText.split(/\r?\n/)[0] || "";
				ritualInput = firstLine;
				if (firstLine) {
					const negationValue =
						(negationInput.value || "不") || "不";
					customDisplays = [
						`${prefixValue}${firstLine}${suffixValue}`,
						`${prefixValue}${negationValue}${firstLine}${suffixValue}`,
					];
				} else {
					customDisplays = [];
				}
			}
			const res = await ritual(
				ritualInput,
				binaryMode ? "" : prefixValue,
				binaryMode ? "" : suffixValue,
				binaryMode ? customDisplays : null
			);
			renderResults(res.entries || []);
			resultNotes.textContent = (res.notes || []).join(" / ");

			if (res.nowParts) {
				const p = res.nowParts;
				const mm = String(p.month).padStart(2, "0");
				const dd = String(p.day).padStart(2, "0");
				const hh = String(p.hour).padStart(2, "0");
				const mi = String(p.minute).padStart(2, "0");
				const ss = String(p.second).padStart(2, "0");
				const l = res.lunar || {};
				meta.textContent = `${l.lunarMonth || "-"}月${l.lunarDay || "-"
					}	${res.zhi || "-"}時刻${res.ke || "-"}`;
			} else {
				meta.textContent = "—";
			}

			setStatus("完成");
		}

		async function copyOut() {
			const lines = currentResults.map(
				({ display, score }) => `${display}\t${score}%`
			);
			const text = lines.join("\n");
			try {
				await navigator.clipboard.writeText(text);
				setStatus("已コピー");
			} catch (e) {
				// Safari/iOS: fallback
				const ta = document.createElement("textarea");
				ta.value = text;
				ta.setAttribute("readonly", "");
				ta.style.position = "fixed";
				ta.style.left = "-9999px";
				document.body.appendChild(ta);
				ta.select();
				ta.setSelectionRange(0, ta.value.length);
				document.execCommand("copy");
				document.body.removeChild(ta);
				setStatus("已コピー");
			}
		}

		btnRun.addEventListener("click", run);
		btnCopy.addEventListener("click", copyOut);
		prefixInput.addEventListener("input", run);
		suffixInput.addEventListener("input", run);
		binaryToggle.addEventListener("click", () => {
			binaryMode = !binaryMode;
			binaryToggle.classList.toggle("is-active", binaryMode);
			binaryToggle.setAttribute("aria-pressed", String(binaryMode));
			binaryToggle.textContent = binaryMode
				? "二選：開"
				: "二選：關";
			negationContainer.hidden = !binaryMode;
			run();
		});
		negationInput.addEventListener("input", run);

		// 快捷鍵：⌘/Ctrl + Enter
		window.addEventListener("keydown", (e) => {
			const isMac = /Mac|iPhone|iPad|iPod/.test(navigator.platform);
			const mod = isMac ? e.metaKey : e.ctrlKey;
			if (mod && e.key === "Enter") {
				e.preventDefault();
				run();
			}
		});
		input.addEventListener("input", run);

		// 首次：给一点结果（不打扰）
		setTimeout(run, 0);
	</script>
</body>

</html>
